<html>
  <head>
    <link rel="stylesheet" type="text/css" href="style.css">

    <!-- Outside imports. -->
    <script type="text/javascript" src="assert.js"></script>
    <script type="text/javascript" src="colour.js"></script>
    <script type="text/javascript" src="jquery.js"></script>

    <script type="text/javascript" src="Constants.js"></script>
    <script type="text/javascript" src="RawBlockData.js"></script>
    <script type="text/javascript" src="Point.js"></script>
    <script type="text/javascript" src="Block.js"></script>
    <script type="text/javascript" src="Key.js"></script>
    <script type="text/javascript" src="KeyRepeater.js"></script>
    <script type="text/javascript" src="Graphics.js"></script>
  </head>

  <body class="centered" onload="initialize()">
    <canvas id="gameBuffer" width=367 height=546>
      <p>
        You are not using a browser that supports the
        <a href="http://www.w3.org/html/wg/html5/">HTML5</a>
        &lt;canvas&gt; feature.
      </p>
    </canvas>
  </body>

  <script>
    var graphics;
    function initialize() {
      graphics = new Graphics($('#gameBuffer'));
    }
  </script>
</html>

<!--onload="load();"-->

<!--
<script type="text/javascript" src="ntrisConstants.js"></script>
<script type="text/javascript" src="ntrisColor.js"></script>
<script type="text/javascript" src="ntrisDataTypes.js"></script>

<script type="text/javascript" src="blockData.js"></script>

<script>
  var gameDiv, gameBuffer;
  var frame = 0;

  // Variables used in key delay simulation
  var keyDown = new Array(NUMKEYS);
  var keyFireFrames = new Array(NUMKEYS);
  var FIRSTKEYDELAY = 7;
  var LATERKEYDELAY = 1;

  // board state, score, combo, and current key-input
  var score, combo;
  var boardState;
  var isMultiplayer;
  var moveDir = new Array();
  var rotated = new Array(2);
  var dropped;
  var held;
  var entered;

  // up-to-date block data
  var curBlock;
  var curBlockType;
  var heldBlockType;

  // store the preview list, as well as its current animation frame
  var preview = new Array();
  var previewAnim;
  var previewOffset;

  // flags which tell us how much of the board we need to redraw this frame
  var holdUsed;
  var boardChanged;
  var justHeld;
  // the old block's position - where to erase
  var oldBlock;

  // description of the blocks already on the board
  var board = new Array();
  for (var i = 0; i < NUMCOLS; i++)
    board.push(new Array(NUMROWS));
  var blocksInRow = new Array(NUMROWS);
  var highestRow;

  function randIndex(max) {
    var rand = Math.random();
    if (rand >= 1)
      rand = 0.99;
    return Math.floor(max * rand);
  }

  function load() {
    initInputs();
    initVectorGraphics();
    openBlockData();

    isMultiplayer = false;
    resetBoard();
    setInterval('update()', 1000/FRAMERATE);
  }

  function initInputs() {
    function getPos(e) {
      var xOffset = document.body.scrollLeft;
      if (xOffset == 0)
        xOffset = window.pageXOffset;
      var yOffset = document.body.scrollTop;
      if (yOffset == 0)
        yOffset = window.pageYOffset;

      var x = e.clientX + xOffset - gameDiv.offsetLeft;
      var y = e.clientY + yOffset - gameDiv.offsetTop;
      var i = parseInt((x - lx)/(size + 1));
      var j = parseInt((y - ly)/(size + 1));
      if ((x < lx) || (i >= cols) || (y < ly) || (j >= rows)) {
        i = -1;
        j = -1;
      }
      return [i, j];
    }

    document = $('document')[0];
    document.onkeydown = function(e) {
      if (!e) e = window.event;
      e.cancelBubble = true;
      if (e.stopPropagation) e.stopPropagation();

      var text = String.fromCharCode(e.keyCode);
      if (e.keyCode == 37) {
        keyDown[MOVELEFT] = true;
      } else if ((e.keyCode == 38) || (text == 'X')) {
        keyDown[MOVEUP] = true;
      } else if (text == 'Z') {
        keyDown[MOVEBACK] = true;
      } else if (e.keyCode == 39) {
        keyDown[MOVERIGHT] = true;
      } else if (e.keyCode == 40) {
        keyDown[MOVEDOWN] = true;
      } else if (text == ' ') {
        keyDown[MOVEDROP] = true;
      } else if ((e.keyCode == 16) || (text == 'C')) {
        keyDown[MOVEHOLD] = true;
      } else if ((e.keyCode == 13) || (text == 'P')) {
        if (entered == false) {
          if (boardState >= GAMEOVER) {
            if ((e.keyCode == 13) && !isMultiplayer)
              resetBoard();
          } else if (boardState >= PAUSED) {
            boardState = PLAYING;
            boardChanged = true;
            previewAnim = 1;
          } else if (boardState == PLAYING) {
            if (!isMultiplayer)
              boardState = PAUSED;
          }
          entered = true;
        }
      }
      return false;
    }

    document.onkeyup = function(e) {
      if (!e) e = window.event;
      e.cancelBubble = true;
      if (e.stopPropagation) e.stopPropagation();

      var text = String.fromCharCode(e.keyCode);
      if (e.keyCode == 37) {
        releaseKey(MOVELEFT);
       } else if ((e.keyCode == 38) || (text == 'X')) {
        releaseKey(MOVEUP);
        rotated[MOVEUP] = false;
       } else if (text == 'Z') {
        releaseKey(MOVEBACK);
        rotated[MOVEBACK] = false;
      } else if (e.keyCode == 39) {
        releaseKey(MOVERIGHT);
      } else if (e.keyCode == 40) {
        releaseKey(MOVEDOWN);
      } else if (text == ' ') {
        releaseKey(MOVEDROP);
        dropped = false;
      } else if ((e.keyCode == 16) || (text == 'C')) {
        releaseKey(MOVEHOLD);
        held = false;
      } else if ((e.keyCode == 13) || (text == 'P')){
        entered = false;
      }
      return false;
    }

    for (var i = 0; i < NUMKEYS; i++) {
      keyDown[i] = false;
      keyFireFrames[i] = -1;
    }
  }

  function releaseKey(key) {
    keyDown[key] = false;
    if (keyFireFrames[key] < 0)
      moveDir.push(key);
    keyFireFrames[key] = -1;
  }

  function queryInputs() {
    for (var i = 0; i < NUMKEYS; i++) {
      if (keyDown[i]) {
        if (keyFireFrames[i] < 0) {
          moveDir.push(i);
          keyFireFrames[i] = FIRSTKEYDELAY;
        } else if (keyFireFrames[i] == 0) {
          moveDir.push(i);
          keyFireFrames[i] = LATERKEYDELAY;
        } else {
          keyFireFrames[i]--;
        }
      }
    }
  }

  function initVectorGraphics() {
    gameDiv = $('#gameBuffer')[0];
    gameBuffer = gameDiv.getContext('2d');

    gameBuffer.drawLine = function(x1, y1, x2, y2) {
      this.beginPath();
      this.moveTo(x1, y1);
      this.lineTo(x2, y2);
      this.stroke();
      this.closePath();
    }
    gameBuffer.fillCircle = function(x, y, r) {
      this.beginPath();
      this.arc(x, y, r, 0, 2*Math.PI, true);
      this.stroke();
      this.fill();
      this.closePath();
    }

    gameBuffer.fillRectOffset = function(x, y, w, h) {
      gameBuffer.fillRect(x + BORDER, y + BORDER, w, h);
    }

    gameBuffer.drawLineOffset = function(x1, y1, x2, y2) {
      gameBuffer.drawLine(x1 + BORDER, y1 + BORDER, x2 + BORDER, y2 + BORDER);
    }

    gameBuffer.fillTextOffset = function(text, x, y) {
      gameBuffer.fillText(text, x + BORDER, y + BORDER);
    }

    gameBuffer.font = '9pt sans-serif';
    gameBuffer.textBaseline = 'middle';
    gameBuffer.fillStyle = 'black';
    gameBuffer.fillRect(0, 0, BOARDWIDTH + 2*BORDER, BOARDHEIGHT + 2*BORDER);
    gameBuffer.fillStyle = colorCode(28);
    gameBuffer.fillRect(BORDER/2 - 1, BORDER/2 - 1, BOARDWIDTH + BORDER + 2, BOARDHEIGHT + BORDER + 2);
    gameBuffer.fillStyle = 'black';
    gameBuffer.fillRect(BORDER/2 + 1, BORDER/2 + 1, BOARDWIDTH + BORDER - 2, BOARDHEIGHT + BORDER - 2);
  }

  function resetBoard() {
    // Clear user input
    rotated[0] = false;
    rotated[1] = false;
    dropped = false;
    held = false;
    entered = false;
    holdUsed = false;
    justHeld = false;

    // Clear the board
    for (var y = 0; y < NUMROWS; y++) {
      for (var x = 0; x < NUMCOLS; x++) {
        board[x][y] = 'black';
      }
      blocksInRow[y] = 0;
    }
    highestRow = NUMROWS;
    boardChanged = true;

    // Reset the preview, held blocks and current block
    preview = new Array();
    previewAnim = 0;
    previewOffset = 0;
    heldBlockType = -1;
    curBlockType = -1;
    oldBlock = new Block();
    curBlock = null;
    moveDir = new Array();

    score = 0;
    combo = 0;
    boardState = RESET;
  }

  function update() {
    frame = (frame + 1) % MAXFRAMENUM;
    queryInputs();
    playTetrisGod()
    timeStep();
    draw();
  }

  function playTetrisGod() {
    var type, level;

    while (preview.length < PREVIEW) {
      if (!isMultiplayer) {
        level = difficultyLevel(score);
        type = randIndex(numBlockTypes[level]);
      }
      preview.push(type);
    }
  }

  function difficultyLevel(s) {
    if (difficultyLevels == 1) {
      return 0;
    }

    var x, p, r;
    p = Math.random();
    if (p < 0) p += 1;

    // calculate the ratio r between the probability of different levels
    x = 2.0 * (s - HALFRSCORE) / HALFRSCORE;
    r = (MAXR - MINR) * (x / Math.sqrt(1 + x * x) + 1) / 2 + MINR;

    // run through difficulty levels and compare p to a sigmoid for each level
    for (var i = 1; i < difficultyLevels; i++) {
      x = 2.0 * (s - (SCOREINTERVAL * i)) / SCOREINTERVAL;
      if (p > Math.pow(r, i) * (x / Math.sqrt(1 + x * x) + 1) / 2) {
        return i - 1;
      }
    }

    return difficultyLevels - 1;
  }

  /* * * * * * * * * * * * * * * * *
   * Tetris game logic starts here *
   * * * * * * * * * * * * * * * * */

  function timeStep() {
    var trans = new Point(0, 0);
    var deltaAngle = 0;
    var moved = false;

    if (boardState == RESET)
      boardState = PLAYING;
    if (boardState != PLAYING)
      return;

    // don't move a non-existent block
    if (curBlock == null) {
      getNextBlock();
      return;
    }

    var command;
    for (i = 0; i < moveDir.length; i++) {
      command = moveDir[i];
      // record the current movement commands
      if ((command == MOVERIGHT) || (command == MOVELEFT)) {
        // the last command is the only one that counts
        trans.x = MOVEDOWN - command;
      } else if ((command == MOVEUP) || (command == MOVEBACK)) {
        if (rotated[command - MOVEUP] == false)   {
          if (curBlock.rotates == true) {
            deltaAngle += (command == MOVEUP ? 1 : 3);
          } else {
            moved = true;
          }
          if (keyDown[command - MOVEUP])
            rotated[command - MOVEUP] = true;
        }
      } else if (command == MOVEDOWN) {
        trans.y++;
      } else if (command == MOVEDROP) {
        if (dropped == false) {
          curBlock.y += curBlock.rowsDropped;
          moveDir = new Array();
          placeBlock(curBlock);
          curBlock = null;
          if (keyDown[MOVEDROP])
            dropped = true;
          return;
        }
      } else if (command == MOVEHOLD) {
        if ((held == false) && (holdUsed == false)) {
          // get the next block by swapping
          moveDir = new Array();
          curBlock = null;
          getNextBlock(true);
          held = true;
          return;
        }
      }
    }
    // clear keys to accept new input
    moveDir = new Array();

    // account for gravity's action on the block
    if (frame % GRAVITY == 0)
      trans.y = 1;

    if (trans.x != 0) {
      // try to move the block right or left, if it is legal
      curBlock.x += trans.x;
      if (checkBlock(curBlock) != OK) {
        // the left and right movement is obstructed - move back
        curBlock.x -= trans.x;
      } else {
        // record the fact that this block moved
        moved = true;
      }
    }

    if (deltaAngle != 0) {
      // try to rotate, if needed
      curBlock.angle += deltaAngle;
      // move left or right to make room to rotate
      // trans.x will record how far we move
      trans.x = 0;
      while ((checkBlock(curBlock)%OVERLAP == LEFTEDGE) || (checkBlock(curBlock)%OVERLAP == RIGHTEDGE)) {
        if (checkBlock(curBlock)%OVERLAP == LEFTEDGE) {
          // rotated off the left edge - move right to compensate
          curBlock.x++;
          trans.x++;
        } else {
          // same on the right edge
          curBlock.x--;
          trans.x--;
        }
      }
      // now the block has been rotated away from the edge
      var check = checkBlock(curBlock);
      if ((check != OK) && (check%OVERLAP != TOPEDGE)) {
        // try to shoveaway from the obstruction, if we have shoveaways left
        if ((curBlock.shoveaways >= MAXSHOVEAWAYS) || (shoveaway(curBlock) == false)) {
          curBlock.angle -= deltaAngle;
          curBlock.x -= trans.x;
        } else {
          // we've burned a shoveaway on this block
          curBlock.shoveaways++;
          moved = true;
        }
      } else if (check%OVERLAP == TOPEDGE) {
        // above the screen - try to move down after rotation
        var deltaY = 1;
        curBlock.y++;
        while (checkBlock(curBlock)%OVERLAP == TOPEDGE) {
          deltaY++;
          curBlock.y++;
        }
        // now check if the block is in a free position
        if (checkBlock(curBlock) ==  OK) {
          moved = true;
        } else {
          // revert to the original angle and x position
          curBlock.angle -= deltaAngle;
          curBlock.x -= trans.x;
          curBlock.y -= deltaY;
        }
      } else {
        // record the fact that this block rotated
        moved = true;
      }
    }

    // if the block moved at all, its local sticking frames are reset
    // also, recalculate the number of squares this block can drop
    if (moved == true) {
      curBlock.localStickFrames = MAXLOCALSTICKFRAMES;
      curBlock.rowsDropped = calculateRowsDropped(curBlock);
    }

    if (curBlock.rowsDropped <= 0) {
      // block cannot drop - start to stick
      curBlock.globalStickFrames--;
      if (moved == false)
        curBlock.localStickFrames--;
    } else {
      // the obstacle is no longer there - reset stick frames, and move down if required
      curBlock.globalStickFrames = MAXGLOBALSTICKFRAMES;
      curBlock.localStickFrames = MAXLOCALSTICKFRAMES;
      curBlock.y += trans.y;
      curBlock.rowsDropped -= trans.y;
    }

    // if the block has no stick frames left, place it down
    if ((curBlock.globalStickFrames <= 0) || (curBlock.localStickFrames <= 0)) {
      placeBlock(curBlock);
      curBlock = null;
    }
  }


  // the shoveaway is a desperate attempt to rotate the block around obstacles
  function shoveaway(block) {
    var dir;

    // don't shoveaway a non-existent block
    if (block == null)
      return false;

    // attempt to rotate the block and possibly translate it
    for (var i = 0; i < 3; i++) {
      // the block can be shifted up to 2 units up in a shoveaway
      if (checkBlock(block) == OK) {
        return true;
      } else {
        // the block can also be shifted 1 unit left or right
        // to avoid giving preference to either direction, we decide randomly which one
        // to try first
        dir = 1 - 2*(1); // the 2*(1) should be a 2*(rand()%2)
        block.x += dir;
        // if either direction works, we return the shoveaway
        if (checkBlock(block) == OK)
          return true;
        block.x -= 2*dir;
        if (checkBlock(block) == OK)
          return true;
        // otherwise, move back to center and shift up again
        block.x += dir;
        block.y--;
      }
    }
    // at the end of the loop, the block has been moved up 3 squares - move it back down
    // no safe position was found, so the shoveaway fails
    block.y += 3;
    return false;
  }

  // place a block on the board, in its new fixed position
  function placeBlock(block) {
    var point = new Point();

    // log this event in multiplayer games
    if (isMultiplayer) {
      events.add(PLACEBLOCK);
      events.add(block.x);
      events.add(block.y);
      events.add(block.angle);
    }

    // don't place a NULL block
    if (block == null)
      return;

    for (var i = 0; i < block.numSquares; i++) {
      // change square coordinates, from local coordinates into global
      if (block.angle%2 == 0) {
        // the block is rotated either 0 or 180 degrees
        point.x = block.x + block.squares[i].x*(1-(block.angle%4));
        point.y = block.y + block.squares[i].y*(1-(block.angle%4));
      } else {
        // the block is rotated either 90 or 270 degrees
        point.x = block.x + block.squares[i].y*((block.angle%4)-2);
        point.y = block.y + block.squares[i].x*(2-(block.angle%4));
      }
      board[point.x][point.y] = block.color;
      blocksInRow[point.y]++;
      if (point.y < highestRow)
        highestRow = point.y;
      boardChanged = true;
    }

    // check if any rows have to be removed
    var rowsCleared = removeRows();
    if (isMultiplayer && rowsCleared > 0) {
      // in a multiplayer game, log the appropriate attack and show an animation
      events.add(SENDATTACK);
      events.add(rowsCleared + ((combo > 1) ? 1 : 0));
    }
  }

  function getNextBlock(swap) {
    if (!swap) swap = false;

    var b;

    // log this event in multiplayer games, except when it is called from queueBlock
    // when curBlockType == -1, this method was called from queueBlock, which is already logged
    if (isMultiplayer) {
      events.add(GETNEXTBLOCK);
      events.add(swap ? 1 : 0);
    }

    if ((!swap) || (heldBlockType == -1)) {
      // get the first element from the preview list - it is the new block
      b = preview[0];
      preview.shift();

      if (swap) {
        heldBlockType = curBlockType;
      }
      // make the preview scroll to the next block
      previewAnim = PREVIEWANIMFRAMES;
      previewOffset = (blockData[b].height+1)*SQUAREWIDTH/2;
    } else {
      // user swapped out block - do not change the preview list
      b = heldBlockType;
      // hold the current block
      heldBlockType = curBlockType;
    }

    // record the new block type
    curBlockType = b;

    curBlock = new Block();
    curBlock.x = blockData[b].x;
    curBlock.y = blockData[b].y - blockData[b].height + MAXBLOCKSIZE;
    curBlock.height = blockData[b].height;
    curBlock.numSquares = blockData[b].numSquares;
    oldBlock.numSquares = blockData[b].numSquares;
    for (var i = 0; i < curBlock.numSquares; i++) {
      curBlock.squares[i].x = blockData[b].squares[i].x;
      curBlock.squares[i].y = blockData[b].squares[i].y;

      oldBlock.squares[i].x = blockData[b].squares[i].x;
      oldBlock.squares[i].y = blockData[b].squares[i].y;
    }
    curBlock.color = blockData[b].color;
    curBlock.rotates = blockData[b].rotates;

    curBlock.rowsDropped = calculateRowsDropped(curBlock);
    if (curBlock.rowsDropped < 0)
      boardState = GAMEOVER;

    if (swap == false) {
      // if we just generated a new block, we can hold again
      holdUsed = false;
    } else {
      holdUsed = true;
      justHeld = true;
    }
  }

  function checkBlock(block) {
    var point = new Point();
    var illegality = 0;
    var overlapsFound = 0;

    // don't check a non-existent block
    if (block == null)
      return OK;

    // run through each square to see if the block is in a legal position
    for (var i = 0; i < block.numSquares; i++) {
      // change square coordinates, from local coordinates into global
      if (block.angle%2 == 0) {
        // the block is rotated either 0 or 180 degrees
        point.x = block.x + block.squares[i].x*(1-(block.angle%4));
        point.y = block.y + block.squares[i].y*(1-(block.angle%4));
      } else {
        // the block is rotated either 90 or 270 degrees
        point.x = block.x + block.squares[i].y*((block.angle%4)-2);
        point.y = block.y + block.squares[i].x*(2-(block.angle%4));
      }

      if (point.y < 0) {
        // the highest priority errors are being off the top or bottom edge
        if (illegality == 0)
          illegality = TOPEDGE;
      } else if (point.y >= NUMROWS) {
        // bottom edge - this can cause the block to stick
        if (illegality == 0) illegality = BOTTOMEDGE;
      } else if (point.x < 0) {
        // block is off the left edge of the board
        if (illegality == 0) illegality = LEFTEDGE;
      } else if (point.x >= NUMCOLS) {
        if (illegality == 0) illegality = RIGHTEDGE;
      } else if (board[point.x][point.y] != 'black') {
        // keep track of the number of overlaps with blocks already placed
        overlapsFound++;
      }
    }

    // the flag returned contains all the information found
    // flag%OVERLAP gives any edges the block strayed over
    // flag/OVERLAP gives the number of overlaps
    // if flag == OK (OK = 0) then the position is legal
    return illegality + OVERLAP*overlapsFound;
  }

  function calculateRowsDropped(block) {
    if (block == null)
      return 0;

    for (var i = 0; i < NUMROWS+1; i++) {
      // check if the block is in a legal position
      if (checkBlock(block) == OK) {
        // still legal - move the block down 1 unit
        block.y++;
      } else {
        // the block is in illegal position - move it back, and
        // return the number of squares it can move down legally
        block.y -= i;
        return i-1;
      }
    }
    return NUMROWS;
  }

  // this method is called each time a block is placed - it clears any full rows
  function removeRows() {
    var downShift = 0;

    for (var y = NUMROWS-1; y >= highestRow; y--) {
      if (blocksInRow[y] == NUMCOLS) {
        // downShift keeps track of the number of cleared rows up to this point
        downShift++;
      } else if (downShift > 0) {
        // down shift this row by downShift rows
        for (var x = 0; x < NUMCOLS; x++) {
          board[x][y+downShift] = board[x][y];
          blocksInRow[y+downShift] = blocksInRow[y];
        }
      }
    }
    // if any rows were removed, add empty space to the top of the board
    if (downShift > 0) {
      for (var y = highestRow; y < highestRow+downShift; y++) {
        for (var x = 0; x < NUMCOLS; x++) {
          board[x][y] = 'black';
          blocksInRow[y] = 0;
        }
      }
      highestRow += downShift;
      score += ((1<<downShift)-1);
      combo++;
    } else combo = 0;

    return downShift;
  }

  /* * * * * * * * * * * * * * * *
   * Drawing routines start here *
   * * * * * * * * * * * * * * * */

  function draw() {
    if (boardState == PLAYING) {
      if (boardChanged == true) {
        redrawBoard();
        boardChanged = false;
      } else {
        drawBoard();
      }
      justHeld = false;
    } else if ((boardState >= PAUSED) && (boardState < GAMEOVER)) {
      if (boardState == PAUSED) {
        gameBuffer.fillStyle = 'black';
        gameBuffer.fillRectOffset(0, 0, BOARDWIDTH, BOARDHEIGHT);

        gameBuffer.fillStyle = 'white';
        gameBuffer.textAlign = 'center';
        gameBuffer.fillTextOffset('-- Paused - press P to resume --', BOARDWIDTH/2, BOARDHEIGHT/2);
        boardState++;
      }
    } else if ((boardState >= GAMEOVER) && (boardState < COUNTDOWN)) {
      if (boardState == GAMEOVER) {
        redrawBoard(true);
        gameBuffer.fillStyle = 'black';
        gameBuffer.fillRectOffset(BOARDWIDTH/2 - 84, BOARDHEIGHT/2 - 20, 168, 40);

        gameBuffer.fillStyle = 'white';
        gameBuffer.textAlign = 'center';
        gameBuffer.textBaseline = 'bottom';
        gameBuffer.fillTextOffset('-- YOU FAILED --', BOARDWIDTH/2, BOARDHEIGHT/2);
        gameBuffer.textBaseline = 'top';
        gameBuffer.fillTextOffset('-- press enter to try again --', BOARDWIDTH/2, BOARDHEIGHT/2);
        gameBuffer.textBaseline = 'middle';
        boardState++;
      }
    }
  }

  function drawBoard() {
    if (justHeld == true) {
      var xOffset = oldBlock.x-blockData[heldBlockType].x;
      var yOffset = oldBlock.y-blockData[heldBlockType].y;

      drawBlock(blockData[heldBlockType], true, false, xOffset, yOffset, oldBlock.angle);
      drawBlock(blockData[heldBlockType], true, false, xOffset, yOffset+oldBlock.rowsDropped, oldBlock.angle);
    } else {
      drawBlock(oldBlock, true, false, 0, 0, 0);
      drawBlock(oldBlock, true, false, 0, oldBlock.rowsDropped, 0);
    }

    if (curBlock != null) {
      drawBlock(curBlock, false, true, 0, curBlock.rowsDropped);
      drawBlock(curBlock);

      oldBlock.x = curBlock.x;
      oldBlock.y = curBlock.y;
      oldBlock.angle = curBlock.angle;
      oldBlock.rowsDropped = curBlock.rowsDropped;
    }

    drawGUI();
  }

  function redrawBoard(tinted, tint) {
    if (!tinted) var tinted = false;
    if (!tint) var tint = 'red';

    var backColor = 'black';
    var lineColor = mixedColor('white', 'black', LAMBDA);
    if (tinted) {
      backColor = mixedColor(tint, backColor, LAMBDA);
      lineColor = mixedColor(tint, lineColor, LAMBDA);
      highestRow = 0;
    }

    // first clear the board with backColor
    gameBuffer.fillStyle = backColor;
    gameBuffer.fillRectOffset(0, 0, SQUAREWIDTH*NUMCOLS, BOARDHEIGHT);

    // draw in the vertical and horizontal grid lines
    gameBuffer.strokeStyle = lineColor;
    gameBuffer.lineWidth = 2;
    for (var i = 0; i < NUMCOLS; i++) {
      gameBuffer.drawLineOffset(SQUAREWIDTH*i, 0, SQUAREWIDTH*i, BOARDHEIGHT-1);
      gameBuffer.drawLineOffset(SQUAREWIDTH*(i+1)-1, 0, SQUAREWIDTH*(i+1)-1, BOARDHEIGHT-1);
    }
    for (var i = 0; i < NUMROWS-MAXBLOCKSIZE+1; i++) {
      gameBuffer.drawLineOffset(0, SQUAREWIDTH*i, SQUAREWIDTH*NUMCOLS-1, SQUAREWIDTH*i);
      gameBuffer.drawLineOffset(0, SQUAREWIDTH*(i+1)-1, SQUAREWIDTH*NUMCOLS-1, SQUAREWIDTH*(i+1)-1);
    }
    // below the highest row, fill in the colors of the blocks there
    for (var y = highestRow; y < NUMROWS; y++) {
      for (var x = 0; x < NUMCOLS; x++) {
        if (tinted) {
          drawSquare(x, y, mixedColor(tint, board[x][y], LAMBDA), (blocksInRow[y] == NUMCOLS));
        } else {
          drawSquare(x, y, board[x][y], (blocksInRow[y] == NUMCOLS));
        }
      }
    }

    if (curBlock != null) {
      drawBlock(curBlock, false, true, 0, curBlock.rowsDropped);
      drawBlock(curBlock);
    }

    drawGUI(tinted, tint);
  }


  function drawGUI(tinted, tint) {
    var listY, digit, i;
    var x = 1;
    var yQueue = 5*(SQUAREWIDTH/2)*(PREVIEW+2);

    // if the board is tinted, we erase the entire GUI right here
    if (tinted == true) {
      gameBuffer.fillStyle = mixedColor(tint, 'black', 1.2*LAMBDA);
      gameBuffer.fillRectOffset(SQUAREWIDTH*NUMCOLS, 0, BOARDWIDTH-SQUAREWIDTH*NUMCOLS, BOARDHEIGHT);
    } else {
      // otherwise, if the preview is scrolling, then we erase the GUI
      if (previewAnim > 0) {
        gameBuffer.fillStyle = 'black';
        gameBuffer.fillRectOffset(SQUAREWIDTH*NUMCOLS, 0, BOARDWIDTH-SQUAREWIDTH*NUMCOLS, yQueue+1);
      }
    }

    // d acts like a y-Offset for the blocks - increases as we go down the preview
    if ((previewAnim > 0) || (tinted == true)) {
      var xOffset = SQUAREWIDTH*NUMCOLS + SIDEBOARD/2 - 3*SQUAREWIDTH/4;
      listY = 0;
      if (previewAnim > 0) listY = (previewOffset*(previewAnim-1))/PREVIEWANIMFRAMES;

      var type;
      for (var j = 0; j < preview.length; j++) {
        type = preview[j];
        if (listY == 0) {
          // the first one is drawn in a bright color
          drawSmallBlock(blockData[type], xOffset, SQUAREWIDTH+listY, SQUAREWIDTH/2, -LAMBDA, tinted, tint);
        } else {
          // all others are drawn in dull colors
          drawSmallBlock(blockData[type], xOffset, SQUAREWIDTH+listY, SQUAREWIDTH/2, 1.2*LAMBDA, tinted, tint);
        }
        listY += (blockData[type].height+2)*SQUAREWIDTH/2;
      }
    }
    if ((holdUsed == true) || (previewAnim > 0) || (tinted == true)) {
      // the following code executes when the held piece changes
      if (tinted == true) {
        gameBuffer.fillStyle = mixedColor(tint, 'black', 1.2*LAMBDA);
        gameBuffer.fillRectOffset(SQUAREWIDTH*NUMCOLS, yQueue+1,
                  BOARDWIDTH-SQUAREWIDTH*NUMCOLS, BOARDHEIGHT-yQueue-1);
      } else {
        gameBuffer.fillStyle = 'black';
        gameBuffer.fillRectOffset(SQUAREWIDTH*NUMCOLS, yQueue+1,
                  BOARDWIDTH-SQUAREWIDTH*NUMCOLS, BOARDHEIGHT-yQueue-1);
      }
      drawHold(holdUsed, tinted, tint);

      previewAnim--;
      if (previewAnim == 0)
        previewOffset = 0;
    } else {
      // when the GUI isn't changing, other than the score, just clear a small rectangle where the score/attack queue will be drawn
      if (!isMultiplayer) {
        gameBuffer.fillStyle = 'black';
        gameBuffer.fillRectOffset(BOARDWIDTH-32-SQUAREWIDTH/2, BOARDHEIGHT-SQUAREWIDTH/2-18, 32, 18);
      }
    }

    if (!isMultiplayer) {
      // draw the score by picking the appropriate tiles from numbers
      gameBuffer.fillStyle = 'white';
      if (tinted)
        gameBuffer.fillStyle = mixedColor(tint, 'white', LAMBDA);
      gameBuffer.textAlign = 'right';
      gameBuffer.fillTextOffset(score, BOARDWIDTH - SQUAREWIDTH/2 - 8,
                    BOARDHEIGHT - SQUAREWIDTH/2 - 8);
      /*
      numbers.x = BOARDWIDTH - SQUAREWIDTH/2 - 8;
      numbers.y = yPos + BOARDHEIGHT - SQUAREWIDTH/2 - 10;
      for (i = 0; i < 4; i++) {
        if ((score >= x) || (i == 0)) {
          digit = (score%(10*x))/x;
          numbers.frameCol = digit+1;
          numbers.draw(g);
          numbers.x -= 8;
        }
        x = 10*x;
      }
      */
    }
  }

  function drawHold(shadow, tinted, tint) {
    var lambda;

    if (shadow == true) {
      // draw the hold rectangle in the GUI to the right, in shadow - signifying that the hold has been used for this block
      lambda = 2*LAMBDA;
    } else {
      // draw the hold rectangle in the GUI to the right in white
      lambda = 0.0;
    }
    var xOffset = SQUAREWIDTH*NUMCOLS+SQUAREWIDTH/2;
    var yOffset = 5*(SQUAREWIDTH/2)*(PREVIEW+2)+1;
    if (tinted == true) {
      gameBuffer.fillStyle = mixedColor(tint, 'white', 3*LAMBDA);
      gameBuffer.fillRectOffset(xOffset, yOffset, 5*SQUAREWIDTH/2, 4*SQUAREWIDTH);
      gameBuffer.fillStyle = mixedColor(tint, 'black', 1.5*LAMBDA);
      gameBuffer.fillRectOffset(xOffset+1, yOffset+1, 5*SQUAREWIDTH/2-2, 4*SQUAREWIDTH-2);
    } else {
      gameBuffer.fillStyle = mixedColor('black', 'white', lambda);
      gameBuffer.fillRectOffset(xOffset, yOffset, 5*SQUAREWIDTH/2, 4*SQUAREWIDTH);
      gameBuffer.fillStyle = 'black';
      gameBuffer.fillRectOffset(xOffset+1, yOffset+1, 5*SQUAREWIDTH/2-2, 4*SQUAREWIDTH-2);
    }

    if (heldBlockType != -1) {
      xOffset = SQUAREWIDTH*NUMCOLS + SIDEBOARD/2 - 3*SQUAREWIDTH/4;
      yOffset += 2*SQUAREWIDTH - ((SQUAREWIDTH/2)*(blockData[heldBlockType].height))/2;
      drawSmallBlock(blockData[heldBlockType], xOffset, yOffset, (SQUAREWIDTH/2), lambda, tinted);
    }
  }

  function drawBlock(block, erase, shadow, xOffset, yOffset, aOffset) {
    if (!erase) var erase = false;
    if (!shadow) var shadow = false;
    if (!xOffset) var xOffset = 0;
    if (!yOffset) var yOffset = 0;
    if (!aOffset) var aOffset = 0;

    var point = new Point();

    // don't draw a non-existent block
    if (block == null)
      return;

    // draw a block, square by square
    for (var i = 0; i < block.numSquares; i++) {
      if ((block.angle+aOffset)%2 == 0) {
        // either the block is unrotated, or rotated 180 degrees - x's correspond to x's
        point.x = block.x + block.squares[i].x*(1-((block.angle+aOffset)%4));
        point.y = block.y + block.squares[i].y*(1-((block.angle+aOffset)%4));
      } else {
        // the block is rotated 90 or 270 degrees - x's in local coordinates are y's in global coords
        point.x = block.x + block.squares[i].y*(((block.angle+aOffset)%4)-2);
        point.y = block.y + block.squares[i].x*(2-((block.angle+aOffset)%4));
      }

      if ((point.x+xOffset >= 0) && (point.x+xOffset < NUMCOLS) &&
          (point.y+yOffset >= 0) && (point.y+yOffset < NUMROWS)) {
        // draw the block at its correct position
        // active blocks are drawn in a lighter color than placed blocks
        if (shadow == false) {
          if (erase == false) {
            drawSquare(point.x+xOffset, point.y+yOffset, block.color);
          } else {
            drawSquare(point.x+xOffset, point.y+yOffset, board[point.x+xOffset][point.y+yOffset]);
          }
        } else {
          drawSquare(point.x+xOffset, point.y+yOffset, block.color, true);
        }
      }
    }
  }

  function drawSmallBlock(block, xOffset, yOffset,
                width, lambda, tinted, tint) {
    if (!tinted) var tinted = false;
    if (!tint) var tint = 'red';

    point = new Point();
    pos = new Point();
    dim = new Point();

    // don't draw a non-existent block
    if (block == null)
      return;

    // draw a block, square by square
    for (var i = 0; i < block.numSquares; i++) {
      if (block.angle%2 == 0) {
        // either the block is unrotated, or rotated 180 degrees - x's correspond to x's
        point.x = block.x + block.squares[i].x*(1-(block.angle%4));
        point.y = block.y + block.squares[i].y*(1-(block.angle%4));
      } else {
        // the block is rotated 90 or 270 degrees - x's in local coordinates are y's in global coords
        point.x = block.x + block.squares[i].y*((block.angle%4)-2);
        point.y = block.y + block.squares[i].x*(2-(block.angle%4));
      }
      pos.x = xOffset + (point.x-NUMCOLS/2+1)*width;
      pos.y = yOffset + point.y*width;
      dim.x = width;
      dim.y = width;
      if (tinted == true) {
        gameBuffer.fillStyle = mixedColor(tint, mixedColor('black', block.color, lambda), 3*LAMBDA);
        gameBuffer.fillRectOffset(pos.x, pos.y, dim.x, dim.y);
      } else {
        gameBuffer.fillStyle = mixedColor('black', block.color, lambda);
        gameBuffer.fillRectOffset(pos.x, pos.y, dim.x, dim.y);
      }
    }
  }

  function drawSquare(x, y, color, shadow) {
    if (!shadow) var shadow = false;

    var pos = new Point();
    var dim = new Point();

    // don't draw the first MAXBLOCKSIZE-1 rows
    // shift the other rows up
    y -= MAXBLOCKSIZE-1;
    if (y < 0) return;

    // draws a specific square
    // first position the drawing square around the border
    pos.x = SQUAREWIDTH*x;
    pos.y = SQUAREWIDTH*y;
    dim.x = SQUAREWIDTH;
    dim.y = SQUAREWIDTH;

    // draw the square's border, a mix of white and the square's color
    if (shadow == false) {
      gameBuffer.fillStyle = mixedColor('white', color, LAMBDA);
      gameBuffer.fillRectOffset(pos.x, pos.y, dim.x, dim.y);
    } else {
      // draw the gray border around a shadowed square
      gameBuffer.fillStyle = mixedColor('white', 'black', LAMBDA);
      gameBuffer.fillRectOffset(pos.x, pos.y, dim.x, dim.y);
    }

    // shrink the square by 1 on all four sides
    pos.x += 1;
    pos.y += 1;
    dim.x -= 3;
    dim.y -= 3;

    // draw the interior of the square in the color board[x][y]
    if (shadow == false) {
      gameBuffer.fillStyle = color;
      gameBuffer.fillRectOffset(pos.x, pos.y, dim.x, dim.y);
    } else {
      gameBuffer.fillStyle = 'black';
      gameBuffer.fillRectOffset(pos.x, pos.y, dim.x, dim.y);
    }

    if (shadow == true) {
      // draw a sequence of diagonal lines to represent the shadow
      gameBuffer.strokeStyle = color;
      gameBuffer.lineWidth = 1;
      for (var i = 0; i < 2*SQUAREWIDTH-1; i++) {
        if (((SQUAREWIDTH*(x+y))+i)%4 == 0) {
          if (i < SQUAREWIDTH) {
            gameBuffer.drawLineOffset(SQUAREWIDTH*x+1, SQUAREWIDTH*y+i,
                SQUAREWIDTH*x+i, SQUAREWIDTH*y);
          } else {
            gameBuffer.drawLineOffset(SQUAREWIDTH*(x+1), SQUAREWIDTH*(y-1)+i+1,
                SQUAREWIDTH*(x-1)+i+1, SQUAREWIDTH*(y+1)-1);
          }
        }
      }
    }
  }
</script>
-->
